# 计时器

计时器与 NSRunLoop 对象一起使用。因此，他们没有提供实时机制 - 他们的准确性有限。如果你只是想在将来的某个时间点发送消息，则可以不使用计时器。

## 计时器和运行循环

计时器由 NSTimer 对象表示。它们与 NSRunLoop 对象一起使用。NSRunLoop 对象控制等待输入的循环，它们使用定时器来帮助确定它们应该等待的最长时间。当计时器的时间限制结束时，运行循环触发计时器（导致其消息被发送），然后检查新输入。

必须运行你注册计时器的运行循环模式才能触发计时器。对于使用 Application Kit 或 UIKit 构建的应用程序，应用程序对象为你运行主线程的运行循环。但是，在辅助线程上，你必须自己运行运行循环 - 有关详细信息，请参阅运行循环。

每个运行循环计时器一次只能在一个运行循环中注册，尽管它可以在该运行循环中添加到多个运行循环模式。

## 时间精确性

计时器不是实时机制;只有当添加了计时器的其中一个运行循环模式正在运行并且能够检查计时器的触发时间是否已经过去时，它才会触发。由于典型的运行循环管理各种输入源，因此定时器的时间间隔的有效分辨率被限制在50-100毫秒的量级。如果在运行循环处于未监视定时器的模式或长调出期间发生定时器的触发时间，则定时器在下次运行循环检查定时器之前不会触发。因此，计时器可能发射的实际时间可能是在计划的发射时间之后的重要时间段。

重复计时器根据计划的点火时间重新安排自己，而不是实际的点火时间。例如，如果计划在特定时间和之后每5秒计时一次计时器，则计划的点火时间将始终落在原始的5秒时间间隔上，即使实际点火时间延迟。如果射击时间延迟到目前为止它通过一个或多个预定的射击时间，则计时器仅在该时间段内被触发一次;然后，在射击之后，计时器被重新安排，用于将来的下一个预定射击时间。

## 计时器的替代品

如果你只是想在将来的某个时间点发送消息，则可以不使用计时器。你可以使用 performSelector:withObject:afterDelay: 和相关方法直接在另一个对象上调用方法。某些变体（例如 performSelectorOnMainThread:withObject:waitUntilDone:）允许你在特定线程上调用该方法。你还可以使用 cancelPreviousPerformRequestsWithTarget: 和相关方法取消延迟消息发送。