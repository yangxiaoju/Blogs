# 并发和应用程序设计

在计算的早期阶段，计算机可以执行的每单位时间的最大工作量取决于 CPU 的时钟速度。但随着技术的进步和处理器设计变得更加紧凑，热量和其他物理限制开始限制处理器的最大时钟速度。因此，芯片制造商寻找其他方法来提高芯片的总体性能。他们解决的解决方案是增加每个芯片上的处理器内核数量。通过增加内核数量，单个芯片可以每秒执行更多指令，而不会增加 CPU 速度或改变芯片尺寸或热特性。唯一的问题是如何利用额外的核心。

为了利用多个核心，计算机需要能够同时执行多项操作的软件。对于像 OS X 或 iOS 这样的现代多任务操作系统，可以在任何给定时间运行一百个或更多程序，因此应该可以在不同核心上安排每个程序。但是，这些程序中的大多数都是系统守护程序或后台应用程序，它们消耗的实际处理时间非常短。相反，真正需要的是各个应用程序更有效地利用额外内核的方法。

应用程序使用多个核心的传统方式是创建多个线程。但是，随着核心数量的增加，线程解决方案也存在问题。最大的问题是线程代码不能很好地扩展到任意数量的内核。你不能创建与核心一样多的线程，并期望程序运行良好。你需要知道的是可以有效使用的核心数量，这对于应用程序自行计算来说是一项具有挑战性的事情。即使你设法得到正确的数字，仍然存在为这么多线程编程，使它们有效运行以及防止它们彼此干扰的挑战。

因此，总结问题，应用程序需要有一种方法来利用可变数量的计算机内核。单个应用程序执行的工作量还需要能够动态扩展以适应不断变化的系统条件。解决方案必须足够简单，以免增加利用这些核心所需的工作量。好消息是 Apple 的操作系统为所有这些问题提供了解决方案，本章将介绍构成此解决方案的技术以及可以对代码进行设计调整以利用它们。

## 远离线程

尽管线程已经存在很多年并且仍在继续使用，但它们并没有解决以可伸缩的方式执行多个任务的一般问题。使用线程，创建可扩展解决方案的负担完全取决于开发人员。你必须决定创建多少线程并在系统条件发生变化时动态调整该数量。另一个问题是你的应用程序承担与创建和维护它使用的任何线程相关的大部分成本。

OS X 和 iOS 采用异步设计方法来解决并发问题，而不是依赖线程。多年来，异步功能已存在于操作系统中，并且通常用于启动可能需要很长时间的任务，例如从磁盘读取数据。调用时，异步函数会在后台执行一些操作以启动任务运行，但在该任务可能实际完成之前返回。通常，这项工作涉及获取后台线程，在该线程上启动所需任务，然后在任务完成时向调用者发送通知（通常通过回调函数）。过去，如果你想要做的事情不存在异步函数，你必须编写自己的异步函数并创建自己的线程。但现在，OS X 和 iOS 提供的技术允许你异步执行任何任务，而无需自己管理线程。

异步启动任务的技术之一是 Grand Central Dispatch（GCD）。此技术采用你通常在自己的应用程序中编写的线程管理代码，并将该代码下移到系统级别。你所要做的就是定义要执行的任务并将它们添加到适当的调度队列中。GCD 负责创建所需的线程并安排在这些线程上运行的任务。由于线程管理现在是系统的一部分，因此 GCD 提供了一种完整的任务管理和执行方法，提供了比传统线程更高的效率。

操作队列是 Objective-C 对象，其行为与调度队列非常相似。你可以定义要执行的任务，然后将它们添加到操作队列，该队列处理这些任务的调度和执行。与 GCD 一样，操作队列为你处理所有线程管理，确保在系统上尽可能快速有效地执行任务。

以下部分提供了有关可在应用程序中使用的调度队列，操作队列和一些其他相关异步技术的详细信息。

### 调度队列（Dispatch Queues）

调度队列是一种用于执行自定义任务的基于 C 的机制。调度队列以串行或并发的顺序执行任务，但始终按先进先出的顺序执行。（换句话说，调度队列始终以与添加到队列相同的顺序出列并启动任务。）串行调度队列一次只运行一个任务，等待该任务完成后再出列并启动新的一个。相比之下，并发调度队列可以在不等待已经启动的任务完成的情况下启动任意数量的任务。

调度队列还有其他好处：

- 它们提供简单易用的编程接口。
- 它们提供自动和整体的线程池管理。
- 它们提供了调整组装的速度。
- 它们的内存效率更高（因为线程堆栈不会留在应用程序内存中）。
- 它们不会在负载下陷入内核。
- 将任务异步分派到调度队列不会使队列死锁。
- 他们在竞争中优雅地扩展。
- 串行调度队列为锁和其他同步原语提供了更有效的替代方案。

你提交给调度队列的任务必须封装在函数或 block 对象中。Block 对象是 OS X v10.6 和 iOS 4.0 中引入的 C 语言特性，在概念上类似于函数指针，但具有一些额外的好处。你通常在另一个函数或方法中定义 blocks，而不是在自己的词法范围中定义 blocks，以便它们可以从该函数或方法访问其他变量。Blocks 也可以移出其原始范围并复制到堆上，这是将它们提交到调度队列时发生的情况。所有这些语义都可以用相对较少的代码实现非常动态的任务。

调度队列是 Grand Central Dispatch 技术的一部分，是 C 运行时的一部分。有关在应用程序中使用调度队列的更多信息，请参阅 Dispatch Queues。有关 blocks 及其优点的更多信息，请参阅 Blocks Programming Topics。

### 调度源（Dispatch Sources）

调度源是一种基于 C 的机制，用于异步处理特定类型的系统事件。调度源封装有关特定类型的系统事件的信息，并在发生该事件时将特定的 block 对象或函数提交给调度队列。你可以使用调度源来监视以下类型的系统事件：

- Timers
- Signal handlers
- Descriptor-related events
- Process-related events
- Mach port events
- Custom events that you trigger

调度源是 Grand Central Dispatch 技术的一部分。有关使用调度源在应用程序中接收事件的信息，请参阅 Dispatch Sources。

### 操作队列（Operation Queues）

操作队列是并发调度队列的 Cocoa 等价物，由 NSOperationQueue 类实现。调度队列始终以先进先出顺序执行任务，而操作队列在确定任务的执行顺序时会考虑其他因素。这些因素中的主要因素是给定任务是否取决于其他任务的完成。你可以在定义任务时配置依赖关系，并可以使用它们为任务创建复杂的执行顺序图。

你提交给操作队列的任务必须是 NSOperation 类的实例。操作对象是一个 Objective-C 对象，它封装了你要执行的工作以及执行它所需的任何数据。因为 NSOperation 类本质上是一个抽象基类，所以通常定义自定义子类来执行任务。但是，Foundation 框架确实包含一些你可以创建和使用的具体子类来执行任务。

操作对象生成键值观察（KVO）通知，这可以是监视任务进度的有用方法。尽管操作队列始终同时执行操作，但你可以使用依赖关系来确保它们在需要时以串行方式执行。

有关如何使用操作队列以及如何定义自定义操作对象的详细信息，请参阅 Operation Queues。

## 异步设计技术

在你考虑重新设计代码以支持并发之前，你应该问自己是否有必要这样做。并发可以确保主线程可以自由响应用户事件，从而提高代码的响应能力。它甚至可以通过利用更多内核在相同的时间内完成更多工作来提高代码的效率。但是，它还会增加开销并增加代码的整体复杂性，从而使编写和调试代码变得更加困难。

因为它增加了复杂性，所以并发性不是你可以在产品周期结束时移植到应用程序的功能。正确地执行操作需要仔细考虑应用程序执行的任务以及用于执行这些任务的数据结构。如果操作不正确，你可能会发现代码运行速度比以前慢，并且对用户的响应速度较慢。因此，在设计周期的开始花一些时间来设置一些目标并考虑你需要采取的方法是值得的。

每个应用程序都有不同的要求和它执行的不同任务集。文档无法准确地告诉你如何设计应用程序及其相关任务。但是，以下部分尝试提供一些指导，以帮助你在设计过程中做出正确的选择。

### 定义应用程序的预期行为

在考虑为应用程序添加并发性之前，应始终先定义你认为应用程序的正确行为。了解应用程序的预期行为可以为你提供以后验证设计的方法。它还应该通过引入并发性来了解你可能获得的预期性能优势。

你应该做的第一件事是枚举应用程序执行的任务以及与每个任务关联的对象或数据结构。最初，你可能希望从用户选择菜单项或单击按钮时执行的任务开始。这些任务提供离散行为，并具有明确定义的起点和终点。你还应该枚举应用程序可能执行的其他类型的任务，而无需用户交互，例如基于计时器的任务。

获得高级任务列表后，开始将每个任务进一步分解为必须采取的成功完成任务所需的步骤集。在此级别，你应主要关注对任何数据结构和对象所需的修改以及这些修改如何影响应用程序的整体状态。你还应该注意对象和数据结构之间的任何依赖关系。例如，如果任务涉及对对象数组进行相同的更改，则值得注意的是对一个对象的更改是否会影响任何其他对象。如果对象可以彼此独立地修改，那么可能是你可以同时进行这些修改的地方。

### 分解可执行的工作单元

根据你对应用程序任务的理解，你应该已经能够识别代码可能从并发中受益的位置。如果更改任务中一个或多个步骤的顺序会更改结果，则可能需要继续按顺序执行这些步骤。但是，如果更改顺序对输出没有影响，则应考虑同时执行这些步骤。在这两种情况下，你都可以定义代表要执行的一个或多个步骤的可执行工作单元。然后，这个工作单元将成为使用 block 或操作对象封装并调度到适当队列的内容。

对于你确定的每个可执行工作单元，至少在开始时不要过多担心正在执行的工作量。虽然启动线程总是有成本，但调度队列和操作队列的一个优点是，在许多情况下，这些成本比传统线程要小得多。因此，你可以使用队列比使用线程更有效地执行更小的工作单元。当然，你应该始终根据需要测量实际性能并调整任务大小，但最初，任何任务都不应该被认为太小。

### 确定你需要的队列

既然你的任务被分解为不同的工作单元并使用 block 对象或操作对象进行封装，则需要定义要用于执行该代码的队列。对于给定任务，请检查你创建的 blocks 或操作对象以及必须执行它们以便正确执行任务的顺序。

如果使用 blocks 实现任务，则可以将 blocks 添加到串行或并发调度队列。如果需要特定订单，则始终将 blocks 添加到串行调度队列。如果不需要特定订单，你可以将 blocks 添加到并发调度队列，或者将它们添加到多个不同的调度队列，具体取决于你的需要。

如果使用操作对象实现任务，则队列的选择通常不如对象的配置有趣。要以串行方式执行操作对象，必须配置相关对象之间的依赖关系。依赖关系阻止一个操作执行，直到它所依赖的对象完成其工作。

### 提高效率的提示

除了简单地将代码分解为较小的任务并将其添加到队列之外，还有其他方法可以使用队列来提高代码的整体效率：

- 如果内存使用是一个因素，请考虑直接在任务中计算值。如果你的应用程序已经受内存限制，则现在直接计算值可能比从主内存加载缓存值更快。计算值直接使用给定处理器核心的寄存器和高速缓存，这比主存储器快得多。当然，如果测试表明这是性能上的胜利，你应该这样做。
- 尽早识别串行任务，尽可能使它们更加并发。如果某个任务必须按顺序执行，因为它依赖于某些共享资源，请考虑更改你的体系结构以删除该共享资源。你可以考虑为每个需要一个客户端的客户端创建资源副本，或者完全取消资源。
- 避免使用锁。调度队列和操作队列提供的支持使得在大多数情况下不需要锁。不使用锁来保护某些共享资源，而是指定一个串行队列（或使用操作对象依赖项）以正确的顺序执行任务。
- 尽可能依靠系统框架。实现并发性的最佳方法是利用系统框架提供的内置并发性。许多框架在内部使用线程和其他技术来实现并发行为。在定义任务时，查看现有框架是否定义了一个完全符合你的要求并同时执行此操作的函数或方法。使用该 API 可以节省你的工作量，并且更有可能为你提供最大的并发性。

## 性能影响

提供操作队列，调度队列和调度源，以便你更容易同时执行更多代码。但是，这些技术并不能保证提高应用程序的效率或响应能力。你仍然有责任以对你的需求有效的方式使用队列，并且不会对你的应用程序的其他资源造成不应有的负担。例如，虽然你可以创建10,000个操作对象并将它们提交到操作队列，但这样做会导致应用程序分配可能非常重要的内存量，这可能会导致分页并降低性能。

在为代码引入任何数量的并发之前 - 无论是使用队列还是线程 - 你应该始终收集一组反映应用程序当前性能的基准指标。在介绍了你的更改之后，你应该收集其他指标并将它们与基线进行比较，以了解你的应用程序的整体效率是否有所提高。如果引入并发性会降低应用程序的效率或响应速度，则应使用可用的性能工具来检查潜在原因。

有关性能和可用性能工具的介绍，以及指向更高级性能相关主题的链接，请参阅 Performance Overview。

## 并发和其他技术

将代码分解为模块化任务是尝试提高应用程序并发性的最佳方法。但是，这种设计方法可能无法满足每种情况下每种应用的需求。根据你的任务，可能还有其他选项可以为应用程序的整体并发性提供额外的改进。本节概述了作为设计一部分考虑使用的其他一些技术。

### OpenCL 和并发

在 OS X 中，开放计算语言（OpenCL）是一种基于标准的技术，用于在计算机的图形处理器上执行通用计算。如果要将一组明确定义的计算应用于大型数据集，OpenCL 是一种很好的技术。例如，你可以使用 OpenCL 对图像的像素执行滤镜计算，或使用它对一次对多个值执行复杂的数学计算。换句话说，OpenCL 更倾向于可以并行操作数据的问题集。

尽管 OpenCL 适用于执行大规模数据并行操作，但它不适用于更通用的计算。准备并将数据和所需的工作内核传输到图形卡所需的工作量非常大，以便 GPU 可以对其进行操作。同样，检索 OpenCL 生成的任何结果需要花费大量精力。因此，通常不建议与系统交互的任何任务与 OpenCL 一起使用。例如，你不会使用 OpenCL 处理来自文件或网络流的数据。相反，使用 OpenCL 执行的工作必须更加独立，以便可以将其传输到图形处理器并独立计算。

有关 OpenCL 以及如何使用它的更多信息，请参阅 OpenCL Programming Guide for Mac。

### 何时使用线程

虽然操作队列和调度队列是同时执行任务的首选方式，但它们并不是灵丹妙药。根据你的应用程序，有时你可能需要创建自定义线程。如果你确实创建了自定义线程，那么你应该尽可能地创建尽可能少的线程，并且你应该仅将这些线程用于无法以任何其他方式实现的特定任务。

线程仍然是实现必须实时运行的代码的好方法。调度队列尽可能快地完成任务，但是它们没有解决实时约束。如果你需要从后台运行的代码中获得更多可预测的行为，则线程仍可提供更好的替代方案。

与任何线程编程一样，你应始终明智地使用线程，并且仅在绝对必要时使用。有关线程包以及如何使用它们的更多信息，请参阅 Threading Programming Guide。