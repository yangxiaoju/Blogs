# 关于线程编程

多年来，最大的计算机性能主要受到计算机核心单个微处理器速度的限制。然而，随着各个处理器的速度开始达到其实际限制，芯片制造商转而采用多核设计，使计算机有机会同时执行多项任务。虽然 OS X 可以利用这些核心来执行与系统相关的任务，但你自己的应用程序也可以通过线程利用它们。

## 什么是线程？

线程是在应用程序内部实现多个执行路径的相对轻量级方式。在系统级，程序并行运行，系统根据需要和其他程序的需要，将执行时间分配给每个程序。然而，在每个程序内部存在一个或多个执行线程，其可用于同时或以几乎同时的方式执行不同的任务。系统本身实际上管理这些执行线程，将它们安排在可用内核上运行，并根据需要抢先中断它们以允许其他线程运行。

从技术角度来看，线程是管理代码执行所需的内核级和应用级数据结构的组合。内核级结构协调事件到线程的调度以及在一个可用内核上的线程的抢占式调度。应用程序级结构包括用于存储函数调用的调用堆栈以及应用程序管理和操作线程属性和状态所需的结构。

在非并发应用程序中，只有一个执行线程。该线程以应用程序的主例程开始和结束，并逐个分支到不同的方法或函数，以实现应用程序的整体行为。相比之下，支持并发的应用程序从一个线程开始，并根据需要添加更多以创建其他执行路径。每个新路径都有自己的自定义启动例程，该例程独立于应用程序主例程中的代码运行。在应用程序中拥有多个线程提供了两个非常重要的潜在优势：

- 多线程可以提高应用程序的感知响应能力。
- 多线程可以提高应用程序在多核系统上的实时性能。

如果你的应用程序只有一个线程，那么一个线程必须执行所有操作。它必须响应事件，更新应用程序的窗口，并执行实现应用程序行为所需的所有计算。只有一个线程的问题是它一次只能做一件事。那么当你的一个计算需要很长时间才能完成时会发生什么？当你的代码忙于计算所需的值时，你的应用程序将停止响应用户事件并更新其窗口。如果此行为持续足够长的时间，用户可能会认为你的应用程序已挂起并尝试强制退出它。但是，如果将自定义计算移动到单独的线程上，则应用程序的主线程可以更及时地响应用户交互。

对于目前常见的多核计算机，线程提供了一种提高某些类型应用程序性能的方法。执行不同任务的线程可以在不同的处理器内核上同时执行，从而使应用程序可以在给定的时间内增加它的工作量。

当然，线程不是解决应用程序性能问题的灵丹妙药。除了线程提供的好处之外，还存在潜在的问题。在应用程序中具有多个执行路径会给代码增加相当大的复杂性。每个线程都必须与其他线程协调其操作，以防止它破坏应用程序的状态信息。由于单个应用程序中的线程共享相同的内存空间，因此它们可以访问所有相同的数据结构。如果两个线程试图同时操作相同的数据结构，则一个线程可能以破坏结果数据结构的方式覆盖另一个线程的更改。即使有适当的保护措施，你仍然需要注意编译器优化，这些优化会在代码中引入细微（而不是那么微妙）的错误。

## 线程术语

在深入讨论线程及其支持技术之前，有必要定义一些基本术语。

如果你熟悉 UNIX 系统，则可能会发现本文档对“任务”一词的使用方式不同。在 UNIX 系统上，术语“任务”有时用于指代正在运行的进程。

本文件采用以下术语：

- 术语线程用于指代代码的单独执行路径。
- 术语进程用于指代正在运行的可执行文件，其可以包含多个线程。
- 术语任务用于指代需要执行的抽象工作概念。

## 线程的替代品

自己创建线程的一个问题是它们会给代码增加不确定性。线程是一种支持应用程序并发性的相对低级且复杂的方法。如果你不完全了解设计选择的含义，则可能很容易遇到同步或计时问题，其严重性可能从细微的行为更改到应用程序崩溃以及用户数据损坏。

另一个要考虑的因素是你是否需要线程或并发。线程解决了如何在同一进程内同时执行多个代码路径的特定问题。但是，在某些情况下，你所做的工作量并不能保证并发性。线程在内存消耗和 CPU 时间方面为你的进程带来了巨大的开销。你可能会发现此开销对于预期任务来说太大了，或者其他选项更容易实现。

表1-1列出了一些线程的替代方案。该表包括线程的替换技术（例如 operation objects 和 GCD）以及旨在有效使用您已有的单线程的替代方法。

表 1-1 线程的替代技术

![](https://github.com/yangxiaoju/Blogs/blob/master/iOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Threading%20Programming%20Guide/1.%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/Table%201-1.png?raw=true)

> 警告：使用 fork 函数启动单独的进程时，必须始终通过调用 exec 或类似函数来调用 fork。依赖于 Core Foundation，Cocoa 或 Core Data 框架（显式或隐式）的应用程序必须对 exec 函数进行后续调用，否则这些框架可能表现不正常。

## 线程支持

如果你有现有使用线程的代码，OS X 和 iOS 提供了几种在应用程序中创建线程的技术。此外，两个系统还支持管理和同步需要在这些线程上完成的工作。以下部分描述了在 OS X 和 iOS 中使用线程时需要注意的一些关键技术。

### 线程包

虽然线程的底层实现机制是 Mach 线程，但很少（如果有的话）使用 Mach 级别的线程。相反，你通常使用更方便的 POSIX API 或其衍生产品之一。然而，Mach 实现确实提供了所有线程的基本功能，包括抢先执行模型和调度线程的能力，因此它们彼此独立。

清单2-2列出了可以在应用程序中使用的线程技术。

表 1-2 线程技术

![](https://github.com/yangxiaoju/Blogs/blob/master/iOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Threading%20Programming%20Guide/1.%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/Table%201-2.png?raw=true)

在应用程序级别，所有线程的行为方式与其他平台上的行为基本相同。启动线程后，线程以三种主要状态之一运行：running，ready 或 blocked。如果一个线程当前没有运行，它将被阻塞并等待输入，或者它已准备好运行但尚未安排执行此操作。线程继续在这些状态之间来回移动，直到它最终退出并移动到终止状态。

创建新线程时，必须为该线程指定入口点函数（或 Cocoa 线程的入口点方法）。此入口点函数构成你要在线程上运行的代码。当函数返回时，或者显式终止线程时，线程将永久停止并由系统回收。由于线程在内存和时间方面的创建成本相对较高，因此建议你的入口点函数执行大量工作或设置运行循环以允许执行重复工作。

有关可用线程技术及其使用方法的更多信息，请参阅 Thread Management。

### 运行循环

运行循环是一个基础结构，用于管理在线程上异步到达的事件。运行循环通过监视线程的一个或多个事件源来工作。当事件到达时，系统唤醒线程并将事件调度到运行循环，然后运行循环将它们分派给你指定的处理程序。如果没有事件存在且准备好处理，则运行循环使线程进入休眠状态。

你不需要对你创建的任何线程使用运行循环，但这样做可以为用户提供更好的体验。运行循环可以创建使用最少量资源的长期线程。因为运行循环在没有任何操作时将其线程置于休眠状态，所以它消除了轮询的需要，这会浪费 CPU 周期并阻止处理器本身休眠并节省电力。

要配置运行循环，你所要做的就是启动线程，获取对运行循环对象的引用，安装事件处理程序，并告诉运行循环运行。OS X 提供的基础结构会自动为你处理主线程运行循环的配置。但是，如果你计划创建长期存在的辅助线程，则必须自己为这些线程配置运行循环。

Run Loops 中提供了有关运行循环的详细信息以及如何使用它们的示例。

### 同步工具

线程编程的一个危险是多线程之间的资源争用。如果多个线程尝试同时使用或修改同一资源，则可能会出现问题。缓解该问题的一种方法是完全消除共享资源，并确保每个线程都有自己独特的资源集来操作。但是，维护完全独立的资源不是一种选择，你可能必须使用锁，条件，原子操作和其他技术来同步对资源的访问。

锁为代码提供强力形式的保护，一次只能由一个线程执行。最常见的锁类型是互斥锁，也称为互斥锁。当一个线程试图获取当前由另一个线程持有的互斥锁时，它会阻塞，直到另一个线程释放该锁。多个系统框架提供对互斥锁的支持，尽管它们都基于相同的底层技术。此外，Cocoa 提供了互斥锁的几种变体，以支持不同类型的行为，例如递归。有关可用锁类型的更多信息，请参阅 Locks。

除锁外，系统还提供对条件的支持，以确保应用程序中任务的正确排序。条件充当网守，阻止给定线程，直到它表示的条件变为真。当发生这种情况时，条件释放线程并允许它继续。POSIX 层和 Foundation 框架都为条件提供直接支持。（如果使用 operation objects，则可以配置 operation objects 之间的依赖关系以对任务的执行进行排序，这与条件提供的行为非常相似。）

虽然锁和条件在并发设计中非常常见，但原子操作是保护和同步数据访问的另一种方法。在可以对标量数据类型执行数学或逻辑运算的情况下，原子操作为锁提供了轻量级替代。原子操作使用特殊的硬件指令来确保在其他线程有机会访问变量之前完成对变量的修改。

有关可用同步工具的详细信息，请参阅 Synchronization Tools。

### 线程间通信

虽然良好的设计可以最大限度地减少所需的通信量，但在某些时候，线程之间的通信变得必要。（线程的工作是为你的应用程序工作，但如果从未使用过该作业的结果，它有什么用处？）线程可能需要处理新的作业请求或将其进度报告给应用程序的主线程。在这些情况下，你需要一种方法来从一个线程获取信息到另一个线程。幸运的是，线程共享相同的进程空间这一事实意味着你有很多通信选项。

线程之间有许多通信方式，每种方式都有自己的优点和缺点。配置线程局部存储列出了你可以在 OS X 中使用的最常见的通信机制。（除了消息队列和 Cocoa 分布式对象，这些技术也可在 iOS 中使用。）此表中的技术按增加的顺序列出复杂。

表 1-3 通信机制

![](https://github.com/yangxiaoju/Blogs/blob/master/iOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Threading%20Programming%20Guide/1.%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/Table%201-3.png?raw=true)

## 设计技巧

以下部分提供了一些指导原则，可帮助你以确保代码正确性的方式实现线程。其中一些指南还提供了使用你自己的线程代码实现更好性能的提示。与任何性能提示一样，你应始终在更改代码之前，期间和之后收集相关的性能统计信息。

### 避免明确地创建线程

手动编写线程创建代码很繁琐且可能容易出错，你应尽可能避免使用它。OS X 和 iOS 通过其他 API 提供对并发的隐式支持。不要自己创建一个线程，而是考虑使用异步 API，GCD 或 operation objects 来完成工作。这些技术为你做幕后的线程相关工作，并保证正确执行。此外，通过根据当前系统负载调整活动线程数，GCD 和 operation objects 等技术可以比你自己的代码更有效地管理线程。有关 GCD 和 operation objects 的更多信息，请参阅 Concurrency Programming Guide。

### 保持你的线程合理繁忙

如果你决定手动创建和管理线程，请记住线程占用宝贵的系统资源。你应该尽力确保分配给线程的任何任务都是合理的长寿和高效的。与此同时，你不应该害怕终止花费大部分时间闲置的线程。线程使用大量内存，其中一些是有线的，因此释放空闲线程不仅有助于减少应用程序的内存占用，还可以释放更多物理内存供其他系统进程使用。

> 要点：在开始终止空闲线程之前，应始终记录应用程序当前性能的一组基线度量。尝试更改后，请进行其他测量以验证更改是否实际上提高了性能，而不是伤害它。

### 避免使用共享数据结构

避免与线程相关的资源冲突的最简单和最简单的方法是为程序中的每个线程提供它所需的任何数据的副本。当你最小化线程之间的通信和资源争用时，并行代码最有效。

创建多线程应用程序很难。即使你非常小心并在代码中的所有正确接合点锁定共享数据结构，你的代码仍可能在语义上不安全。例如，如果希望以特定顺序修改共享数据结构，则代码可能会遇到问题。将代码更改为基于事务的模型以进行补偿可能随后会抵消具有多个线程的性能优势。首先消除资源争用通常会导致设计更简单，性能更佳。

### 线程和你的用户界面

如果你的应用程序具有图形用户界面，建议你从应用程序的主线程接收与用户相关的事件并启动界面更新。此方法有助于避免与处理用户事件和绘制窗口内容相关的同步问题。某些框架（如 Cocoa）通常需要此行为，但即使对于那些不这样做的框架，将此行为保留在主线程上也具有简化管理用户界面的逻辑的优势。

有一些值得注意的例外情况，从其他线程执行图形操作是有利的。例如，你可以使用辅助线程来创建和处理图像，并执行其他与图像相关的计算。使用辅助线程进行这些操作可以大大提高性能。如果你不确定特定的图形操作，请计划从主线程执行此操作。

有关 Cocoa 线程安全性的更多信息，请参阅 Thread Safety Summary。有关使用 Cocoa 绘图的更多信息，请参阅 Cocoa Drawing Guide。

### 在退出时意识到线程行为

进程将一直运行，直到所有未分离的线程都退出。默认情况下，只将应用程序的主线程创建为非分离，但你也可以创建其他线程。当用户退出应用程序时，通常认为立即终止所有分离的线程是合适的行为，因为分离线程完成的工作被认为是可选的。但是，如果你的应用程序使用后台线程将数据保存到磁盘或执行其他关键工作，你可能希望将这些线程创建为非分离，以防止在应用程序退出时丢失数据。

将线程创建为非分离（也称为可连接）需要你做额外的工作。由于大多数高级线程技术默认情况下不创建可连接线程，因此你可能必须使用 POSIX API 来创建线程。此外，你必须在应用程序的主线程中添加代码，以便在最终退出时与非分离线程连接。有关创建可连接线程的信息，请参阅 Setting the Detached State of a Thread。

如果你正在编写 Cocoa 应用程序，你还可以使用 applicationShouldTerminate: delegate 方法将应用程序的终止延迟到以后的时间或完全取消它。延迟终止时，你的应用程序需要等待任何关键线程完成其任务，然后调用 replyToApplicationShouldTerminate: 方法。有关这些方法的详细信息，请参阅 NSApplication Class Reference。

### 处理例外情况

异常处理机制依赖于当前调用堆栈在抛出异常时执行任何必要的清理。因为每个线程都有自己的调用堆栈，所以每个线程都负责捕获自己的异常。未能在辅助线程中捕获异常与未在主线程中捕获异常相同：拥有进程终止。你不能将未捕获的异常抛出到其他线程进行处理。

如果你需要通知当前线程中异常情况的另一个线程（例如主线程），你应该捕获异常并简单地向另一个线程发送消息，指示发生了什么。根据你的模型和你要执行的操作，捕获异常的线程可以继续处理（如果可能），等待指令，或者只是退出。

> 注意：在 Cocoa 中，NSException 对象是一个自包含的对象，一旦被捕获就可以从一个线程传递给另一个线程。

在某些情况下，可能会自动为你创建异常处理程序。例如，Objective-C 中的 @synchronized 指令包含一个隐式异常处理程序。

### 干净地终止你的线程

线程退出的最佳方法当然是让它到达主入口点例程的末尾。虽然有立即终止线程的函数，但这些函数应该仅作为最后的手段使用。在线程到达其自然终点之前终止线程可防止线程自行清理。如果线程已分配内存，打开文件或获取其他类型的资源，则代码可能无法回收这些资源，从而导致内存泄漏或其他潜在问题。

有关退出线程的正确方法的更多信息，请参阅 Terminating a Thread。

### 库的线程安全

虽然应用程序开发人员可以控制应用程序是否使用多个线程执行，但库开发人员却没有。在开发库时，你必须假设调用应用程序是多线程的，或者可以随时切换到多线程。因此，你应始终对关键的代码段使用锁。

对于库开发人员，仅在应用程序变为多线程时才创建锁是不明智的。如果你需要在某个时刻锁定代码，请在使用库的早期创建锁定对象，最好是在某种显式调用中初始化库。虽然你也可以使用静态库初始化函数来创建此类锁，但只有在没有其他方法时才尝试这样做。执行初始化函数会增加加载库所需的时间，并可能对性能产生负面影响。

> 注意：始终记得平衡调用以锁定和解锁库中的互斥锁。你还应该记住锁定库数据结构，而不是依赖调用代码来提供线程安全的环境。

如果你正在开发 Cocoa 库，那么如果你希望在应用程序变为多线程时收到通知，则可以注册为 NSWillBecomeMultiThreadedNotification 的观察者。但是，你不应该依赖于接收此通知，因为它可能会在调用库代码之前调度。