# 提高动画效果

核心动画是提高基于应用程序的动画的帧速率的好方法，但它的使用并不能保证提高性能。特别是在 OS X 中，你仍然必须选择使用 Core Animation 行为的最有效方法。与所有与性能相关的问题一样，你应该使用 Instruments 来衡量和跟踪应用程序的性能，以便确保性能得到改善而不是回归。

## 为你的 OS X 视图选择最佳重绘策略

NSView 类的默认重绘策略保留该类的原始绘制行为，即使该视图是图层支持的。如果你在应用中使用图层支持的视图，则应检查重绘策略选项并选择为你的应用提供最佳性能的选项。在大多数情况下，默认策略不是可能提供最佳性能的策略。相反，NSViewLayerContentsRedrawOnSetNeedsDisplay 策略更有可能减少应用程序的绘制量并提高性能。其他策略也可能为特定类型的视图提供更好的性能。

有关视图重绘策略的详细信息，请参阅 The Layer Redraw Policy for OS X Views Affects Performance。

## 更新 OS X 中的图层以优化渲染路径

在 OS X v10.8 及更高版本中，视图有两个用于更新底层图层内容的选项。在 OS X v10.7 及更早版本中更新图层支持的视图时，图层会将视图的 drawRect: 方法中的绘图命令捕获到支持位图图像中。缓存绘图命令很有效，但在所有情况下都不是最有效的选项。如果你知道如何直接提供图层的内容而不实际渲染它们，则可以使用 updateLayer 方法执行此操作。

有关渲染的不同路径（包括涉及 updateLayer方法的路径）的信息，请参阅 Using a Delegate to Provide the Layer’s Content。

## 一般提示和技巧

有几种方法可以提高图层实现的效率。但是，与任何此类优化一样，在尝试优化之前，应始终测量代码的当前性能。这为你提供了一个基线，可用于确定优化是否有效。

### 尽可能使用不透明层

将图层的 opaque 属性设置为 YES 可让 Core Animation 知道它不需要为图层维护 alpha 通道。没有 Alpha 通道意味着合成器不需要将图层的内容与其背景内容混合，这样可以在渲染过程中节省时间。但是，此属性主要与作为图层支持视图一部分的图层或 Core Animation 创建基础图层位图的情况相关。如果将图像直接指定给图层的 contents 属性，则无论 opaque 属性中的值如何，都会保留该图像的 Alpha 通道。

### 对 CAShapeLayer 对象使用更简单的路径

CAShapeLayer 类通过在复合时将你提供的路径渲染到位图图像来创建其内容。优点是该层总是以尽可能好的分辨率绘制路径，但这种优势是以额外的渲染时间为代价的。如果你提供的路径很复杂，那么栅格化该路径可能会过于昂贵。如果图层的大小经常变化（因此必须经常重绘），绘制所花费的时间可能会增加并成为性能瓶颈。

最小化形状层的绘制时间的一种方法是将复杂形状分解为更简单的形状。使用更简单的路径并在合成器中将多个 CAShapeLayer 对象叠加在一起可以比绘制一个大的复杂路径快得多。这是因为绘图操作发生在 CPU 上，而合成发生在 GPU 上。与此类性质的任何简化一样，潜在的性能提升取决于你的内容。因此，在优化之前测量代码的性能尤为重要，这样你就可以使用基线进行比较。

### 为相同的图层显式设置图层内容

如果在多个图层对象中使用相同的图像，请自行加载图像并将其直接指定给这些图层对象的 contents 属性。将图像分配给 contents 属性可防止图层为后备存储分配内存。相反，该图层使用你提供的图像作为其后备存储。当多个图层使用相同的图像时，这意味着所有这些图层共享相同的内存，而不是为自己分配图像的副本。

### 始终将图层的大小设置为整数值

为获得最佳效果，请始终将图层对象的宽度和高度设置为整数值。虽然使用浮点数指定图层边界的宽度和高度，但图层边界最终用于创建位图图像。指定宽度和高度的整数值可简化 Core Animation 在创建和管理后备存储和其他图层信息时必须执行的工作。

### 根据需要使用异步层渲染

你在委托的 drawLayer 中执行的任何 drawLayer:inContext: 方法或视图的 drawRect: 方法通常在应用程序的主线程上同步发生。但在某些情况下，同步绘制内容可能无法提供最佳性能。如果你注意到动画效果不佳，可以尝试在图层上启用 drawAsynchronously 属性，将这些操作移动到后台线程。如果这样做，请确保你的绘图代码是线程安全的。和往常一样，在将其放入生产代码之前，应始终异步测量绘图的性能。

### 在为图层添加阴影时指定阴影路径

让 Core Animation 确定阴影的形状可能很昂贵并影响应用程序的性能。不要让 Core Animation 确定阴影的形状，而是使用 CALayer 的 shadowPath 属性显式指定阴影形状。为此属性指定路径对象时，Core Animation 使用该形状绘制和缓存阴影效果。对于形状永不变化或很少更改的图层，可以通过减少 Core Animation 完成的渲染量来大大提高性能。