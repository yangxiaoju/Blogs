# 在后台下载文件

创建在应用处于非活动状态时下载文件的任务。

## 概览

对于长时间运行和非长期传输，你可以创建在后台运行的任务。即使你的应用程序被暂停，这些任务仍会继续运行，从而允许你的应用在应用恢复时访问下载的文件。

> 注意：你不必使用本文所述的后台会话执行所有后台网络活动。声明适当后台模式的应用程序可以使用默认 URL 会话和数据任务，就像它们位于前台一样。

## 配置后台会话

要执行后台下载，请为后台操作配置 URLSession。清单1演示了此过程。

1. 使用 URLSession 的类方法 background(withIdentifier:) 创建后台 URLSessionConfiguration 对象，提供应用程序中唯一的会话标识符。由于大多数应用程序只需要几个后台会话（通常是一个），因此你可以使用固定字符串作为标识符，而不是动态生成的标识符。标识符不需要全局唯一。
2. 要让系统在任务完成且应用程序在后台时唤醒你的应用程序，请确保将 sessionSendsLaunchEvents 属性设置为 true（默认值）。
3. 对于时间不敏感的任务，启用 isDiscretionary 属性，以便系统可以等待最佳条件来执行传输，例如设备插入或连接到 Wi-Fi 时。
4. 使用 URLSessionConfiguration 实例创建 URLSession 实例。提供 delegate，从后台转移接收事件。

清单 1 创建后台 URL 会话

```swift
private lazy var urlSession: URLSession = {
    let config = URLSessionConfiguration.background(withIdentifier: "MySession")
    config.isDiscretionary = true
    config.sessionSendsLaunchEvents = true
    return URLSession(configuration: config, delegate: self, delegateQueue: nil)
}()
```

> 注意：有关系统如何安排和执行后台任务的更多信息，请从“错误报告配置文件和日志”页面下载背景网络配置文件并将其安装到 iOS 设备上。

## 创建并安排下载任务

你可以使用带有 URL 的 downloadTask(with:) 方法或带有 URLRequest 实例的 downloadTask(with:) 方法从会话创建下载任务。你可以在此方法上设置属性以帮助系统优化其行为。

1. 如清单2所示，使用 downloadTask(with:) 创建下载任务。
2. （可选）设置 earliestBeginDate 属性以将下载安排在将来的特定点开始。下载不能保证在这个时间开始，但它不会很快开始。
3. 要帮助系统有效地调度网络活动，请设置属性 countOfBytesClientExpectsToSend 和 countOfBytesClientExpectsToReceive。这些值是预期字节数的最佳猜测上限，应该考虑 header 和 body 数据。
4. 要启动任务，请调用 resume()。

在清单2中，任务设置为在将来至少开始一小时，并配置为发送大约200字节的数据并接收大约 500KB。

清单 2 从 URL 会话创建下载任务

```swift
let backgroundTask = urlSession.downloadTask(with: url)
backgroundTask.earliestBeginDate = Date().addingTimeInterval(60 * 60)
backgroundTask.countOfBytesClientExpectsToSend = 200
backgroundTask.countOfBytesClientExpectsToReceive = 500 * 1024
backgroundTask.resume()
```

## 处理应用程序暂停

不同的应用状态会影响你的应用与后台下载的互动方式。在 iOS 中，你的应用可能处于前台，暂停甚至终止系统。有关这些状态的详细信息，请参阅 Managing Your App's Life Cycle for more information about these states。

如果你的应用程序位于后台，系统可能会在其他进程中执行下载时暂停你的应用程序。在这种情况下，当下载完成时，系统将恢复应用程序并调用 UIApplicationDelegate 方法 application(_:handleEventsForBackgroundURLSession:completionHandler:)。此方法接收你在清单1中创建的会话标识符作为其第二个参数。

此 delegate 方法还接收 completion handler 作为其最终参数。立即将此处理程序存储在适合你的应用程序的任何位置，可能作为应用程序委托的属性，或实现 URLSessionDownloadDelegate 的类。在清单3中，此完成处理程序存储在名为 backgroundCompletionHandler 的 app delegate 属性中。

清单 3 存储发送给应用程序委托的后台下载 completion handler

```swift
func application(_ application: UIApplication,
                 handleEventsForBackgroundURLSession identifier: String,
                 completionHandler: @escaping () -> Void) {
        backgroundCompletionHandler = completionHandler
}
```

当所有事件都已传递时，系统将调用 URLSessionDelegate 的 urlSessionDidFinishEvents(forBackgroundURLSession:) 方法。此时，获取清单3中 app delegate 存储的 backgroundCompletionHandler 并执行它。清单4显示了这个过程。

请注意，因为可以在辅助队列上调用 urlSessionDidFinishEvents(forBackgroundURLSession:)，所以它需要在主队列上显式执行处理程序（从 UIKit 方法接收）。

清单 4 在主队列上执行后台 URL 会话 completion handler

```swift
func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {
    DispatchQueue.main.async {
        guard let appDelegate = UIApplication.shared.delegate as? AppDelegate,
            let backgroundCompletionHandler =
            appDelegate.backgroundCompletionHandler else {
                return
        }
        backgroundCompletionHandler()
    }
}
```

## 访问文件，或将其移动到永久位置

一旦你的恢复应用程序调用 completion handler，下载任务就会完成其工作并调用委托的 urlSession(_:downloadTask:didFinishDownloadingTo:) 方法。此时，文件已完全下载，并且在你的委托方法返回之前可用。如果你只需要阅读一次，则可以立即在其临时位置访问该文件。如果要保留文件，请将其移动到诸如 Documents 目录之类的永久位置，如 Downloading Files from Websites 中所述。

## 如果应用程序被终止，请重新创建会话

如果系统在暂停时终止应用程序，系统会在后台重新启动应用程序。作为启动时间设置的一部分，使用与以前相同的会话标识符重新创建后台会话（参见清单1），以允许系统将后台下载任务与会话重新关联。这样做是为了让你的后台会话准备就绪，无论应用程序是由用户还是系统启动的。应用程序重新启动后，一系列事件与应用程序已暂停和恢复的情况相同，如之前在 Handle App Suspension 中所述。

> 注意：如果在应用程序处于后台时启动传输，则会话配置的 isDiscretionary 属性将被视为 true。

## 遵守 Background Transfer Limitations

对于后台会话，实际传输由与应用程序进程分开的进程执行。由于重新启动应用程序的过程相当昂贵，因此一些功能不可用，从而导致以下限制：

- 会话必须提供事件传递的代表。（对于上载和下载，代理的行为与进程内传输的行为相同。）
- 仅支持 HTTP 和 HTTPS 协议（无自定义协议）。
- 始终遵循重定向。因此，即使你已实现 urlSession(_:task:willPerformHTTPRedirection:newRequest:completionHandler:)，也不会调用它。
- 仅支持从文件上传任务（从应用程序退出后从数据实例上传或流失败）。

## 有效地使用背景会话

当系统恢复或重新启动你的应用时，它会使用速率限制器来防止滥用后台下载。当你的应用在后台启动新的下载任务时，任务在延迟到期之前不会开始。每次系统恢复或重新启动应用程序时，延迟都会增加。

因此，如果你的应用程序启动单个后台下载，在下载完成后恢复，然后开始新的下载，则会大大增加延迟。相反，使用少量后台会话 - 理想情况下只使用一个 - 并使用这些会话一次启动许多下载任务。这允许系统一次执行多个下载，并在完成后恢复你的应用程序。

但请记住，每个任务都有自己的开销。如果你发现需要启动数千个下载任务，请更改设计以执行更少，更大的传输。

> 注意：只要用户将你的应用程序带到前台，延迟就会重置为0。如果在没有系统恢复或重新启动应用程序的情况下延迟时间过去，它也会重置。