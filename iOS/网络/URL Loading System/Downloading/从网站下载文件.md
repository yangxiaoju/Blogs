# 从网站下载文件

将文件直接下载到文件系统。

## 概览

对于已存储为文件（如图像和文档）的网络资源，你可以使用下载任务直接将这些项目提取到本地文件系统。

> 技巧：你还可以配置下载任务，以便在应用程序暂停或在后台终止时运行。有关详细信息，请 Downloading Files in the Background for details。

## 对于简单下载，请使用 Completion Handler

要下载文件，请从 URLSession 创建 URLSessionDownloadTask。如果你不关心在下载过程中接收进度更新或其他 delegate 回调，则可以使用 completion handler。下载结束时，任务在成功下载结束或下载失败时调用 completion handler。

你的 completion handler 可能会收到客户端错误，指示本地问题，例如无法访问网络。如果没有客户端错误，你还会收到一个 URLResponse，你应该检查它以确保它指示服务器的响应成功。

如果下载成功，则 completion handler 将收到一个 URL，指示下载文件在本地文件系统上的位置。这个存储是暂时的。如果要保留文件，必须在从 completion handler 返回之前从该位置复制或移动它。

清单1显示了使用 completion handler 创建下载任务的简单示例。如果未指示错误，则完成处理程序将下载的文件移动到应用程序的 Documents 目录。 通过调用 resume() 启动任务。

清单 1 使用 completion handler 创建下载任务

```swift
let downloadTask = URLSession.shared.downloadTask(with: url) {
    urlOrNil, responseOrNil, errorOrNil in
    // check for and handle errors:
    // * errorOrNil should be nil
    // * responseOrNil should be an HTTPURLResponse with statusCode in 200..<299
    
    guard let fileURL = urlOrNil else { return }
    do {
        let documentsURL = try
            FileManager.default.url(for: .documentDirectory,
                                    in: .userDomainMask,
                                    appropriateFor: nil,
                                    create: false)
        let savedURL = documentsURL.appendingPathComponent(
            fileUrl.lastPathComponent)
        try FileManager.default.moveItem(at: fileUrl, to: savedURL)
    } catch {
        print ("file error: \(error)")
    }
}
downloadTask.resume()
```

> Tip：清单1使用 downloadTask(with:) 创建下载任务，它只需要一个 URL 参数。如果你需要自定义发送到服务器的请求，请使用 downloadTask(with:) 创建任务并传入自定义的 URLRequest。

## 要接收进度更新，请使用 Delegate

如果要在下载过程中接收进度更新，则必须使用 delegate。你可以从 URLSessionTaskDelegate 和 URLSessionDownloadDelegate 协议接收对方法实现的回调，而不是在 completion handler 中接收结果。

创建自己的 URLSession 实例，并设置其 delegate 属性。清单2显示了一个懒惰实例化的 urlSession 属性，该属性将 self 设置为其委托。

清单 2 使用 delegate 创建 URL 会话

```swift
private lazy var urlSession = URLSession(configuration: .default,
                                         delegate: self,
                                         delegateQueue: nil)
```

要开始下载，请使用此 URLSession 创建 URLSessionDownloadTask，然后通过调用 resume() 启动任务，如清单3所示。

清单 3 创建和启动使用 delegate 的下载任务

```swift
private func startDownload(url: URL) {
    let downloadTask = urlSession.downloadTask(with: url)
    downloadTask.resume()
    self.downloadTask = downloadTask
}
```

## 接收进度更新

下载开始后，你将在 URLSessionDownloadDelegate 方法 urlSession(_:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:) 中定期收到进度更新。你可以使用此回调提供的字节数来更新应用中的进度 UI。

清单4显示了此回调方法的实现。此实现计算下载的小数进度，并使用它来更新以百分比显示进度的标签。由于回调是在未知的 Grand Central Dispatch 队列上执行的，因此你必须在主队列上显式执行 UI 更新。

清单 4 使用 delegate 方法更新 UI 中的下载进度

```swift
func urlSession(_ session: URLSession,
                downloadTask: URLSessionDownloadTask,
                didWriteData bytesWritten: Int64,
                totalBytesWritten: Int64,
                totalBytesExpectedToWrite: Int64) {
     if downloadTask == self.downloadTask {
        let calculatedProgress = Float(totalBytesWritten) / Float(totalBytesExpectedToWrite)
        DispatchQueue.main.async {
            self.progressLabel.text = self.percentFormatter.string(from:
                NSNumber(value: calculatedProgress))
    }
}
```

> Tip：如果你在下载期间需要执行的唯一 UI 更新是更新 UIProgressView，则使用任务的 progress 属性而不是执行你自己的进度计算。此属性是 Progress 的实例，你可以在创建任务以自动更新进度视图时将其分配给 UIProgressView 属性 observedProgress。

## 处理下载 Delegate 中的完成或错误

当你使用 delegate 而不是 completion handler 时，你通过实现 urlSession(_:downloadTask:didFinishDownloadingTo:) 来处理下载的完成。检查 downloadTask 的响应属性以确保服务器响应指示成功。如果是，则 location 参数提供存储文件的本地URL。此位置仅在回调结束前有效。这意味着你必须立即读取文件，或者在从回调方法返回之前将其移动到其他位置，例如应用程序的 Documents 目录。清单5显示了如何保留下载的文件。

清单 5 将下载的文件保存在 delegate 回调中

```swift
func urlSession(_ session: URLSession,
                downloadTask: URLSessionDownloadTask,
                didFinishDownloadingTo location: URL) {
    // check for and handle errors:
    // * downloadTask.response should be an HTTPURLResponse with statusCode in 200..<299

    do {
        let documentsURL = try
            FileManager.default.url(for: .documentDirectory,
                                    in: .userDomainMask,
                                    appropriateFor: nil,
                                    create: false)
        let savedURL = documentsURL.appendingPathComponent(
            location.lastPathComponent)
        try FileManager.default.moveItem(at: location, to: savedURL)
    } catch {
        // handle filesystem error
    }
}
```

如果发生客户端错误，你的委托会在回调 urlSession(_:task:didCompleteWithError:) delegate 方法时收到它。另一方面，如果下载成功完成，则在 urlSession(_:downloadTask:didFinishDownloadingTo:) 之后调用此方法，错误为 nil。