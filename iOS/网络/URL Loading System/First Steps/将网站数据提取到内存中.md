# 将网站数据提取到内存中

通过从 URL 会话创建数据任务将数据直接接收到内存中。

## 概览

对于与远程服务器的小型交互，你可以使用 URLSessionDataTask 类将响应数据接收到内存中（而不是使用 URLSessionDownloadTask 类，它将数据直接存储到文件系统中）。数据任务非常适合调用 Web 服务端点等用途。

你使用 URL 会话实例来创建任务。如果你的需求非常简单，则可以使用 URLSession 类的共享实例。如果要通过 delegate 回调与传输进行交互，则需要创建会话而不是使用共享实例。你在创建会话时使用 URLSessionConfiguration 实例，还传入实现 URLSessionDelegate 或其子协议之一的类。可以重用会话来创建多个任务，因此，对于你需要的每个唯一配置，创建会话并将其存储为属性。

> 注意：小心不要创建超出需要的会话。例如，如果你的应用程序的多个部分需要类似配置的会话，请创建一个会话并在它们之间共享。

完成会话后，使用 dataTask() 方法之一创建数据任务。任务在挂起状态下创建，可以通过调用 resume() 来启动。

## 使用 Completion Handler 接收结果

获取数据的最简单方法是创建使用 completion handler 的 data task。通过这种安排，任务将服务器的响应，数据和可能的错误传递给你提供的 completion handler block。图1显示了会话和任务之间的关系，以及如何将结果传递给 completion handler。

图 1 创建 completion handler 以接收任务的结果

![](https://docs-assets.developer.apple.com/published/c7124fb5d7/bf4501ff-82b2-4dd4-9ec3-243ef0e70d21.png)

要创建使用完成处理程序的数据任务，请调用 URLSession 的 dataTask(with:) 方法。你的 completion handler 需要做三件事：

1. 验证 error 参数是否为 nil。如果不是，则发生传输错误; 处理错误并退出。
2. 检查响应参数以验证状态代码是否指示成功，以及 MIME 类型是否为预期值。如果没有，请处理服务器错误并退出。
3. 根据需要使用数据实例。

清单1显示了一个用于获取 URL 内容的 startLoad() 方法。它首先使用 URLSession 类的共享实例创建一个 data task，将结果传递给 completion handler。检查本地和服务器错误后，此 handler 将数据转换为字符串，并使用它来填充 WKWebView 插座。当然，你的应用程序可能对获取的数据有其他用途，例如将其解析为数据模型。

清单 1 创建 completion handler 以接收数据加载结果

```swift
func startLoad() {
    let url = URL(string: "https://www.example.com/")!
    let task = URLSession.shared.dataTask(with: url) { data, response, error in
        if let error = error {
            self.handleClientError(error)
            return
        }
        guard let httpResponse = response as? HTTPURLResponse,
            (200...299).contains(httpResponse.statusCode) else {
            self.handleServerError(response)
            return
        }
        if let mimeType = httpResponse.mimeType, mimeType == "text/html",
            let data = data,
            let string = String(data: data, encoding: .utf8) {
            DispatchQueue.main.async {
                self.webView.loadHTMLString(string, baseURL: url)
            }
        }
    }
    task.resume()
}
```

> 重要：在与创建任务的队列不同的 Grand Central Dispatch 队列上调用完成处理程序。因此，任何使用数据或错误更新 UI 的工作（如更新 webView）都应明确放在主队列上，如下所示。

## 通过 Delegate 接收转移详细信息和结果

为了在任务活动进行时更高级别地访问任务，在创建 data task 时，你可以在会话上设置 delegate，而不是提供 completion handler。图2显示了这种安排。

图 2 实现 delegate 以接收任务的结果

![](https://docs-assets.developer.apple.com/published/8b22355c7f/730c8e1b-654f-4eb9-9c63-d439a69ac5d2.png)

使用这种方法，部分数据在 URLSessionDataDelegate 到达时提供给 urlSession(_:dataTask:didReceive:) 方法，直到传输完成或失败并出现错误。随着转移的进行，delegate 也会收到其他类型的事件。

你需要在使用 delegate 方法时创建自己的 URLSession 实例，而不是使用 URLSession 类的简单共享实例。创建新会话允许你将自己的类设置为会话的 delegate，如清单2所示。

声明你的类实现了一个或多个 delegate 协议（URLSessionDelegate，URLSessionTaskDelegate，URLSessionDataDelegate和URLSessionDownloadDelegate）。 然后使用初始化程序 init(configuration:delegate:delegateQueue:) 创建 URL 会话实例。你可以自定义与此初始化程序一起使用的配置实例。例如，将 waitsForConnectivity 设置为 true 是个好主意。这样，会话等待合适的连接，而不是在所需的连接不可用时立即失败。

清单 2 创建使用 delegate 的 URLSession

```swift
private lazy var session: URLSession = {
    let configuration = URLSessionConfiguration.default
    configuration.waitsForConnectivity = true
    return URLSession(configuration: configuration,
                      delegate: self, delegateQueue: nil)
}()
```

清单3显示了一个 startLoad() 方法，它使用此会话来启动数据任务，并使用 delegate 回调来处理收到的数据和错误。此列表实现了三个 delegate 回调：

- urlSession(_:dataTask:didReceive:completionHandler:) 验证响应是否具有成功的 HTTP 状态代码，以及 MIME 类型是 text/html 还是 text/plain。如果不是这种情况，则任务被取消; 否则，它被允许继续。
- urlSession(_:dataTask:didReceive:) 获取任务接收的每个 Data 实例，并将其附加到名为 receivedData 的缓冲区。
- urlSession(_:task:didCompleteWithError:) 首先查看是否发生了传输级错误。如果没有错误，它会尝试将 receivedData 缓冲区转换为字符串并将其设置为 webView 的内容。

清单 3 使用具有 URL 会话 data task 的 delegate

```swift
var receivedData: Data?

func startLoad() {
    loadButton.isEnabled = false
    let url = URL(string: "https://www.example.com/")!
    receivedData = Data()
    let task = session.dataTask(with: url)
    task.resume()
}

// delegate methods

func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive response: URLResponse,
                completionHandler: @escaping (URLSession.ResponseDisposition) -> Void) {
    guard let response = response as? HTTPURLResponse,
        (200...299).contains(response.statusCode),
        let mimeType = response.mimeType,
        mimeType == "text/html" else {
        completionHandler(.cancel)
        return
    }
    completionHandler(.allow)
}

func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data) {
    self.receivedData?.append(data)
}

func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {
    DispatchQueue.main.async {
        self.loadButton.isEnabled = true
        if let error = error {
            handleClientError(error)
        } else if let receivedData = self.receivedData,
            let string = String(data: receivedData, encoding: .utf8) {
            self.webView.loadHTMLString(string, baseURL: task.currentRequest?.url)
        }
    }
}
```

各种代理协议提供的方法超出了上述代码中所示的方法，用于处理身份验证挑战，重定向后跟踪以及其他特殊情况。在 URLSession 讨论中，使用 URL 会话描述了传输过程中可能发生的各种回调。