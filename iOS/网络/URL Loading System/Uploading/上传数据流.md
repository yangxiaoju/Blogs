# 上传数据流

将数据流发送到服务器。

## 概览

流媒体应用程序和长时间运行的应用程序发送连续更新使用正在进行的流上传数据，而不是发送单个数据块或平面文件。你可以配置 URLSessionUploadTask（URLSessionTask 的子类）的实例以使用你提供的流，然后无限期地使用数据填充此流。

该任务通过调用会话的 delegate 来获取流，因此你需要创建会话并将你自己的代码设置为其 delegate。

## 创建一个 URL 会话

首先创建一个 URLSession 并为其提供 delegate。清单1使用默认的 URLSessionConfiguration 创建一个 URL 会话，并将 self 设置为 delegate。稍后，你将在 Provide the Stream to the Upload Task 中实现 URLSessionTaskDelegate。

清单 1 使用 delegate 创建 URLSession

```swift
lazy var session: URLSession = URLSession(configuration: .default,
                                          delegate: self,
                                          delegateQueue: .main)
```

## 创建流式上传任务

使用 URLSession 方法 uploadTask(withStreamedRequest:) 创建上传任务。这需要一个 URLRequest，指定要上传到的 URL 以及其他参数。你可以通过调用 resume() 来启动任务。清单2显示了如何创建和启动上传任务，连接到本地计算机上的服务器（127.0.0.1），侦听端口12345。

清单 2 创建上传任务

```swift
let url = URL(string: "http://127.0.0.1:12345")!
var request = URLRequest(url: url,
                         cachePolicy: .reloadIgnoringLocalCacheData,
                         timeoutInterval: 10)
request.httpMethod = "POST"
let uploadTask = session.uploadTask(withStreamedRequest: request)
uploadTask.resume()
```

## 使用绑定流对提供输入流

你将流数据作为 InputStream 提供给上传任务。该任务从此流中读取数据并将其上传到目标。

向输入流提供数据的好方法是使用绑定的流对。绑定对包含你将数据写入的 OutputStream。由于流的绑定，你写入输出流的数据可供输入流使用，然后可以从中读取任务。图1显示了这种安排。

图 1 使用绑定的流对向上传任务提供数据

![](https://docs-assets.developer.apple.com/published/da31e34bc2/a29fb2be-5f7f-4c56-9ef6-4090ecfbae82.png)

清单3显示了一个名为 Streams 的结构，它由 InputStream 和 OutputStream 组成。该列表通过调用 Stream 类的 getBoundStreams(withBufferSize:inputStream:outputStream:) 方法创建此类型的属性，称为 boundStreams，传入输入和输出流的 in-out 引用。

清单 3 创建一对绑定的输入和输出流

```swift
struct Streams {
    let input: InputStream
    let output: OutputStream
}
lazy var boundStreams: Streams = {
    var inputOrNil: InputStream? = nil
    var outputOrNil: OutputStream? = nil
    Stream.getBoundStreams(withBufferSize: 4096,
                           inputStream: &inputOrNil,
                           outputStream: &outputOrNil)
    guard let input = inputOrNil, let output = outputOrNil else {
        fatalError("On return of `getBoundStreams`, both `inputStream` and `outputStream` will contain non-nil streams.")
    }
    // configure and open output stream
    output.delegate = self
    output.schedule(in: .current, forMode: .default)
    output.open()
    return Streams(input: input, output: output)
}()
```

创建绑定对时，请确保指定一个足够大的缓冲区大小，以便在从输入流中读取数据之前保存你写入输出流的任何数据。清单3使用4096字节的缓冲区。

该列表还将 self 设置为输出流的 delegate。声明你的类实现了 StreamDelegate 协议，以便接收指示输出流何时准备好接收新数据的事件。稍后你将提供 StreamDelegate 的实现，在将数据写入流时准备就绪。

> 技巧：你的 StreamDelegate 和 URLSessionTaskDelegate 的实现可能位于同一个类或不同的类中，无论哪个对你的应用程序的体系结构更有意义。

## 将流提供给上传任务

你在 URLSessionTaskDelegate 方法 urlSession(_:task:needNewBodyStream:) 的实现中为上传任务提供输入流，该方法在你通过调用 resume() 启动上传任务后调用。回调传递一个 completion handler，你可以直接调用它，传入你之前创建的 boundStreams.input流。清单4显示了此方法的实现。

清单 4 在 delegate 回调中向上传任务提供输入流

```swift
func urlSession(_ session: URLSession, task: URLSessionTask,
                needNewBodyStream completionHandler: @escaping (InputStream?) -> Void) {
    completionHandler(boundStreams.input)
}
```

## 当数据准备就绪时将数据写入流

仅在流准备好时才将数据写入输出流。你将收到 StreamDelegate 方法 stream(_:handle:) 中流的准备情况的通知。当此回调将 hasSpaceAvailable 作为其 eventCode 参数发送时，该流已准备好接受更多数据。

如果你在处理事件时没有准备好编写，并且希望按照自己的计划编写，则可以设置一个标志变量并稍后检查以确定是否可以安全地写入流。清单5说明了这种技术。它通过将私有 canWrite 属性设置为 true 来处理 hasSpaceAvailable 事件。

处理流事件时，还要检查 eventCode 是否为 errorOccurred。这意味着流已失败。发生这种情况时，请关闭流并放弃上传。

清单 5 处理 StreamDelegate 事件

```swift
func stream(_ aStream: Stream, handle eventCode: Stream.Event) {
    guard aStream == boundStreams.output else {
        return
    }
    if eventCode.contains(.hasSpaceAvailable) {
        canWrite = true
    }
    if eventCode.contains(.errorOccurred) {
        // Close the streams and alert the user that the upload failed.
    }
}
```

处理完 hasSpaceAvailable 事件后，只要知道它已准备好接收更多数据，就可以写入流。你通过调用其 write(_:maxLength:) 方法写入流，提供对要写入的原始字节的引用，以及要写入的最大字节数。

清单6使用一个计时器来等待私有 canWrite 属性变为 true。在这种情况下，代码会创建一个表示当前日期的字符串并将其转换为原始字节。然后列表调用 write(_:maxLength:) 将这些字节发送到输出流。由于此输出流绑定到输入流，因此上传任务可以自动从输入流中读取这些字节并将它们发送到目标 URL。

清单 6 当流有可用空间时，创建一个定时器以写入输出流

```swift
timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) {
    [weak self] timer in
    guard let self = self else { return }

    if self.canWrite {
        let message = "*** \(Date())\r\n"
        guard let messageData = message.data(using: .utf8) else { return }
        let messageCount = messageData.count
        let bytesWritten: Int = messageData.withUnsafeBytes() { (buffer: UnsafePointer<UInt8>) in
            self.canWrite = false
            return self.boundStreams.output.write(buffer, maxLength: messageCount)
        }
        if bytesWritten < messageCount {
            // Handle writing less data than expected.
        }
    }
}
```

> 技巧：如果要传输的数据来自异步进程（如来自媒体捕获设备的回调），则在写入之前仍需等待输出流准备就绪。在这些情况下，你可以使用循环缓冲区来保存数据，直到流准备好接受它。

写入输出流后，在 StreamDelegate 收到新的 hasSpaceAvailable 事件之前，你无法再次写入。此示例通过将类的 canWrite 属性设置为 false 来强制实施此约束。当输出流的 delegate 收到新的 hasSpaceAvailable 事件时，它将重置为 true，如清单5中所示。

